#!/usr/bin/env ruby
#
#  USAGE
#
#  build a base file that contains an empty project
#
#
#  hustle new [base image]
#
#  SYNTAX
#
#  hustle build [dev image]        # build image
#  hustle new [base image]         # creates new dev env based on base image
#
#  hustle stop [container]             # stop container
#  hustle start, s [env = dev]     # start dev container
#    -w                            # watch for changes (file-owner-sync)
#
#  hustle pristine [container]         # stop and remove container from docker
#  hustle rebuild, [dev]           # rebuild container
#
#  hustle sync [dev]               # copy dev app files to local
#  hustle file-owner-sync [dev]    # watch for new files and sync
#  hustle run [cmd] [container]        # run command on container
#  hustle debug                    # Shell into new container based off container
#  hustle shell                    # Shell into running container
#
require 'optparse'


class Hustler < Struct.new(:argv, :options)
  DOT_FILE = '.env'

  def fetch_command(cmd)
    docker_compose = {
      start:  "docker-compose up #{options[:daemonize]}",
      stop:   "docker-compose down",
      build:  "docker-compose build",
      remove: "",
    }

    docker = {
      start:  "docker run #{ports} #{link} #{options[:daemonize]} --name #{image} #{image}",
      stop:   "docker stop #{image}",
      build:  "docker build . --no-cache=true -t #{image}",
      remove: "docker rm #{image}",
    }

    (compose? ? docker_compose : docker)[cmd.to_sym]
  end

  def debug
    leave_script_and_exec(%|docker run -it --entrypoint=/bin/bash #{image} -s|)
  end

  def stop
    exec_within_script fetch_command(:stop)
  end

  def remove
    exec_within_script fetch_command(:remove)
  end

  def remove_image
    exec_within_script "docker rmi #{image}"
  end

  def stop_and_remove
    stop && remove
  end

  def start
    exec_within_script fetch_command(:start)
  end

  def compose?
    File.exist?('docker-compose.yaml')
  end

  def restart
    stop_and_remove && start
  end

  def run(cmd)
    puts exec_within_script(%|docker exec #{image} sh -c "#{cmd}"|)
  end

  def build
    exec_within_script fetch_command(:build)
  end

  def shell
    cmd = "docker exec -t -i #{image} /bin/bash"
    leave_script_and_exec(cmd)
  end

  def new_app
    require 'digest/sha1'
    if args.length != 1
      puts "SYNTAX\n\nhustle new [image]"
      exit 1
    end
    base_image = args.first

    @dev_container = "#{base_image.sub(/base$/,'app')}-#{Digest::SHA1.hexdigest(Time.now.to_s)[0..5]}"
    File.write(DOT_FILE, "CONTAINER_NAME=#{dev_container}")

    puts "Attempting to start container based on #{base_image}"
    `docker run -d --name #{image} #{base_image}`

    puts "Copying #{image}:/app to local"
    `docker cp #{image}:/app $(pwd)`

    puts "Removing #{image}"
    stop_and_remove

    puts "Building new image #{image}"
    build
  end

  def execute
    case command
    when 'new'
      new_app
    when "rebuild", "build"
      build
    when "file-owner-sync"
      run("export USERID=#{Process.uid} && export GROUPID=#{Process.gid} && file-chown-sync")
    when "run-hard"
      leave_script_and_exec(args.join(' '))
    when "run"
      run(args.join(' '))
    when 'debug'
      debug
    when "shell"
      shell
    when "restart", "r"
      restart
    when "start", "s"
      start
    when "stop"
      stop
    when "rm"
      remove
    when 'pristine'
      stop_and_remove && remove_image
    else
      puts "\n\nERROR: hustle '#{command}' does not exist. Run 'hustle --help'"
      puts "\n\nConfig:\n\n\t#{config.inspect}\n\n"
      puts "\n\nOptions:\n\n\t#{options.inspect}\n\n"
    end
  end

  def prod_container 
    "#{dev_container}-prod"
  end

  def env
    config('env') || options.fetch(:env, "development")
  end

  def config(key = nil)
    @config ||= load_config!
    key.nil? ? @config : @config.fetch(key, "No value for :#{key}")
  end

  def dev_container
    @dev_container ||= config 'CONTAINER_NAME'
  end

  private

  def load_config!(file = DOT_FILE)
    if File.exists?(DOT_FILE)
      File.readlines(DOT_FILE).each_with_object({}) do |line, hsh|
        key, value = line.split(/=/).map(&:strip)
        hsh[key] = value
      end
    else
      raise "Unable to find '#{DOT_FILE}' in current directory"
    end
  end

  def ports
    "-p #{options.fetch(:ports, "3000:3000")}"
  end

  def link
    options[:link] || '-v $(pwd)/myapp:/myapp'
  end

  def leave_script_and_exec(cmd)
    cmd = cmd.squeeze ' '
    puts "Running: #{cmd}"
    exec cmd # Use Kernel#exec to kill this script and replace with cmd
  end

  def exec_within_script(cmd)
    cmd = cmd.squeeze ' '
    puts "running: #{cmd}"
    retval = `#{cmd}`
    if (status = $?.exitstatus).zero? 
      retval
    else
      puts "ERROR #{status}"
      exit status
    end
  end

  def image
    if options[:service]
      config "#{options[:service]}_container_name".upcase
    else
      options[:env] == "production" ? prod_container : dev_container
    end
  end

  def app_dir
    super || "app"
  end

  def command 
    argv.first
  end

  def args
    argv.drop(1)
  end
end


options = {}
OptionParser.new do |opts|
  opts.banner = <<-EOS
  Side Hustle Kit Command Line App. Copyright 2017. SHK, Inc.

  USAGE

  hustle build [image]                # build image
  hustle new [image]                  # creates new dev env based on base image

  hustle stop [container]             # stop container
  hustle start [container]            # start dev container
  hustle shell [container]            # open shell on running container

  hustle pristine [container]         # stop and remove container from docker
  hustle rebuild, [container]         # rebuild container

  hustle sync [container]             # copy dev app files to local
  hustle file-owner-sync [container]  # watch for new files and sync
  hustle run [cmd] [-s service]       # run command on service from within script
  hustle run-hard [cmd] [container]   # leave script and run command on container

  EOS

  opts.on("-v", "--[no-]verbose", "Run verbosely") do |v|
    options[:verbose] = v
  end

  opts.on("-d", "Run as daemon") do
    options[:daemonize] = '-d'
  end

  opts.on("-e", "--env ENV", "Environment") do |env|
    options[:env] = env
  end

  opts.on("-nl", "--no-links", "Do not link to shared volume") do
    options[:link] = ""
  end

  opts.on("-l", "--link LINK", "Link to shared volume") do |link|
    options[:link] = link
  end

  opts.on("-f", "--force", "Force action") do
    options[:force] = '-f'
  end

  opts.on("-p", "--ports external:internal", "Link external to interal ports") do |ports|
    options[:ports] = ports
  end

  opts.on("-s", "--service [web|db||]", "Service to target with command, defaults to web") do |service|
    options[:service] = service
  end

  opts.on("-h", "--help", "Show this help message") do
    puts opts
  end
end.parse!

Hustler.new(ARGV, options).execute
